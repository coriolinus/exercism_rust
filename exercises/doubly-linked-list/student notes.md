# Doubly Linked List Notes

- `Option<NonNull<*mut Node<T>>>` is a bit verbose, but was fairly straightforward to research
- `(**next.as_ref())` feels like a weird pattern, but appears to work
- there are some rustc warnings about deprecated idioms; that's fine, this branch hasn't been updated in a while; we just need to fix them
- there are some rustfmt changes to the test files; no big deal
- it took longer to get the first test passing than I'd initially expected. The README notes on breaking down the implementation in phases seem good and useful; I just hadn't known to expect that `Drop` would need to be implemented for the first test to pass. Once I'd figured that out and implemented it reasonably, I needed to either bypass the cursor stuff, or implement a suitable subset of the cursor in order to move forward. However, I'm not sure at this time if there's a better way to do things than what is already in place.
- the `Cursor::take` implementation used here seems _really_ kind of hackish; I'm not certain that this is doing exactly what I want it to do. OTOH, it casues the first test to pass, so woohoo!
- In particular, it looks like this may be the _only_ way to extract an owned value from a pointer? That's exactly what `take` requires, so I'm doing it, but I'm really not thrilled by this "shove in some uninitialized memory and yoink the real value for myself" strategy I'm using.
- Also, wasn't there a thing recently where we're supposed to use `mem::MaybeUninit` or something similar instead of `mem::uninitialized`? I think I remember reading about that, but it looks like the former isn't in autocomplete yet. TODO: look this up and do the recommended thing.
- it looks like my cursor implementation differs somewhat from the one expected; perhaps I was supposed to write something like `pub struct Cursor<T>(&mut Node<T>);`? But when I tried that, it was a hassle converting from a raw pointer to a reference all the time. Perhaps when I look at this again, I'll see a good way to abstract that conversion.
- it's not immediately clear whether or not `insert_before` and `insert_after` should move the current position of the cursor. Looking at `pre_implemented.rs`, it looks like those functions were specifically written to be agnostic to that choice, which doesn't actually help. In the end, I chose to move it: it moves when we insert into an empty list, therefore it should move when we insert into a non-empty list. Hopefully the test suite shows that the decision was correct.
- ran into a really bizarre situation where tests pass when there exists a `dbg!()` macro invocation, but hang when that invocation is removed. Adding more `dbg!()` invocations to attempt to figure it out required adding `T: std::fmt::Debug` bounds everywhere, which ended up being quite a lot of changes. Still not sure what's happening there, but it feels bizarre.
- after quite a bit of debugging, it looks like I'm prematurely dropping the node. Don't tell me: I needed to allocate it on the heap, not the stack. I bet that has something to do with it.
- it definitely feels like I'm triangulating in on a correct implementation; the more tests already pass, the easier it is to make the next one pass. That's a very good thing, IMO.
- spent a while last night frustrated because the compiler was fighting me very hard when I tried to implement `Iter<T>` in terms of a reference to a `Cursor<T>`. Looking at it with fresh eyes today, it seemed pretty clear that the lifetime requirements just weren't the same. With that revelation, it was pretty smooth to implement. Then, when I was done, I remembered that I'd had a fairly lengthy discussion last year with @Emerentius hashing out that we had to have both `Cursor<T>` and `Iter<T>` for _precisely_ this reason: their lifetime and API requirements just aren't compatible. 
- heh. Looks like I wasn't quite finished pointer-wrangling in my inserts. This is a good test suite; I'm glad it caught errors like that!
- I implemented `Display` for `LinkedList<T>` and `Cursor<T>` because the `dbg!()` macro is great, but it's even better when I can get a picture of the whole state at once. I wonder how many other students will do this?